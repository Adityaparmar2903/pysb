import inspect
from pysb import *
import pysb.core
from pysb.core import ComponentSet
import numbers

__all__ = ['two_state_equilibrium',
           'bind', 'bind_table',
           'catalyze', 'catalyze_state', 'catalyze_table',
           'catalyze_one_step', 'catalyze_one_step_reversible',
           'synthesize_and_degrade', 'synthesize_and_degrade_table',
           'assemble_pore_sequential', 'pore_transport']

## Internal helper functions
def _complex_pattern_label(cp):
    """Return a string label for a ComplexPattern."""
    mp_labels = [_monomer_pattern_label(mp) for mp in cp.monomer_patterns]
    return ''.join(mp_labels)

def _monomer_pattern_label(mp):
    """Return a string label for a MonomerPattern."""
    site_values = [str(x) for x in mp.site_conditions.values() if x is not None]
    return mp.monomer.name + ''.join(site_values)

def _macro_rule(rule_prefix, rule_expression, klist, ksuffixes):
    """A helper function for writing macros that generates a single rule.

    Parameters
    ----------
    rule_prefix : string
        The prefix that is prepended to the (automatically generated) name for
        the rule.
    rule_expression : RuleExpression
        An expression specifying the form of the rule; gets passed directly
        to the Rule constructor.
    klist : list of Parameters or list of numbers
        If the rule is unidirectional, the list must contain one element
        (either a Parameter or number); if the rule is reversible, it must
        contain two elements. If the rule is reversible, the first element
        in the list is taken to be the forward rate, and the second element
        is taken as the reverse rate. 
    ksuffixes : list of strings
        If klist contains numbers rather than Parameters, the strings in
        ksuffixes are used to automatically generate the necessary Parameter
        objects. The suffixes are appended to the rule name to generate the
        associated parameter name. ksuffixes must contain one element if the
        rule is unidirectional, two if it is reversible.

    Returns
    -------
    components : ComponentSet
        The generated components. Contains the generated Rule and up to two
        generated Parameter objects (if klist was given as numbers).

    Notes
    -----
    The generated rule name follows the form

        '%s_%s_to_%s' % (rule_prefix, lhs_label, rhs_label)

    where lhs_label is generated by iteratively calling _complex_pattern_label
    on each ComplexPattern on the left-hand side of the RuleExpression, and
    similarly for rhs_label.

    Examples
    --------
    Using distinct Monomers for substrate and product::

        >>> from pysb import *
        >>> from pysb.macros import _macro_rule
        >>> 
        >>> Model() # doctest:+ELLIPSIS
        <Model '<interactive>' (monomers: 0, rules: 0, parameters: 0, compartments: 0) at ...>
        >>> Monomer('A', ['s'])
        Monomer(name='A', sites=['s'], site_states={})
        >>> Monomer('B', ['s'])
        Monomer(name='B', sites=['s'], site_states={})
        >>> 
        >>> _macro_rule('bind', A(s=None) + B(s=None) <> A(s=1) % B(s=1), [1e6, 1e-1], ['kf', 'kr'])
        {'bind_A_B_to_A1B1': Rule(name='bind_A_B_to_A1B1', reactants=A(s=None) + B(s=None), products=A(s=1) % B(s=1), rate_forward=Parameter(name='bind_A_B_to_A1B1_kf', value=1000000.0), rate_reverse=Parameter(name='bind_A_B_to_A1B1_kr', value=0.1)),
         'bind_A_B_to_A1B1_kf': Parameter(name='bind_A_B_to_A1B1_kf', value=1000000.0),
         'bind_A_B_to_A1B1_kr': Parameter(name='bind_A_B_to_A1B1_kr', value=0.1)}
        >>> 

    """
    
    # Get reactant pattern
    react_p = rule_expression.reactant_pattern
    prod_p = rule_expression.product_pattern
    # Build the rule_name
    lhs_label = [_complex_pattern_label(cp) for cp in react_p.complex_patterns]
    lhs_label = '_'.join(lhs_label)
    rhs_label = [_complex_pattern_label(cp) for cp in prod_p.complex_patterns]
    rhs_label = '_'.join(rhs_label)
    r_name = '%s_%s_to_%s' % (rule_prefix, lhs_label, rhs_label)

    # If rule is unidirectional, make sure we only have one parameter
    if (not rule_expression.is_reversible):
        if len(klist) != 1 or len(ksuffixes) != 1:
            raise ValueError("A unidirectional rule must have one parameter.")
    # If rule is bidirectional, make sure we have two parameters
    else:
        if len(klist) != 2 or len(ksuffixes) != 2:
            raise ValueError("A bidirectional rule must have two parameters.")

    if all(isinstance(x, Parameter) for x in klist):
        k1 = klist[0]
        if rule_expression.is_reversible:
            k2 = klist[1]
        params_created = ComponentSet([])
    # if klist is numbers, generate the Parameters
    elif all(isinstance(x, numbers.Real) for x in klist):
        k1 = Parameter('%s_%s' % (r_name, ksuffixes[0]), klist[0])
        params_created = ComponentSet([k1]) 
        if rule_expression.is_reversible:
            k2 = Parameter('%s_%s' % (r_name, ksuffixes[1]),
                           klist[1])
            params_created |= ComponentSet([k2])
    else:
        raise ValueError("klist must contain Parameter objects or " +
            "a list of (name, number) tuples")

    if rule_expression.is_reversible:
        r = Rule(r_name, rule_expression, k1, k2)
    else:
        r = Rule(r_name, rule_expression, k1)

    # Build a set of components that were created
    return ComponentSet([r]) | params_created

def _verify_sites(m, *site_list):
    """Checks that the monomer m contains all of the sites in site_list.

    Parameters
    ----------
    m : Monomer or MonomerPattern
        The monomer to check.
    site1, site2, ... : string
        One or more site names to check on m

    Returns
    -------
    True if m contains all sites; raises a ValueError otherwise.

    Raises
    ------
    ValueError
        If any of the sites are not found.
    """

    for site in site_list:
        if site not in m().monomer.sites_dict:
            raise ValueError("Monomer '%s' must contain the site '%s'" %
                            (m().monomer.name, site))
    return True

## Unimolecular patterns
def two_state_equilibrium(s1, s2, klist):
    """Generate the unimolecular reversible equilibrium reaction S1 <-> S2.

    Parameters
    ----------
    s1, s2 : Monomer or MonomerPattern
        S1 and S2 in the above reaction.
    klist : list of 2 Parameters or list of 2 numbers
        Forward (S1 -> S2) and reverse rate constants (in that order). If
        Parameters are passed, they will be used directly in the generated
        Rules. If numbers are passed, Parameters will be created with
        automatically generated names based on the names and states of S1 and S2
        and these parameters will be included at the end of the returned
        component list.

    Returns
    -------
    components : ComponentSet
        The generated components. Contains one reversible Rule and optionally
        two Parameters if klist was given as plain numbers.
    """
    
    # turn any Monomers into MonomerPatterns
    return _macro_rule('equilibrate', s1() <> s2(), klist, ['kf', 'kr'])

## Binding
def bind(s1, site1, s2, site2, klist):
    """Generate the reversible binding reaction S1 + S2 <> S1:S2.

    Parameters
    ----------
    s1, s2 : Monomer or MonomerPattern
        Monomers participating in the binding reaction.
    site1, site2 : string 
        The names of the sites on s1 and s2 used for binding.
    klist : list of 2 Parameters or list of 2 numbers
        Forward and reverse rate constants (in that order). If Parameters are
        passed, they will be used directly in the generated Rules. If numbers
        are passed, Parameters will be created with automatically generated
        names based on the names and states of S1 and S2 and these parameters
        will be included at the end of the returned component list.

    Returns
    -------
    components : ComponentSet
        The generated components. Contains the bidirectional binding Rule
        and optionally two Parameters if klist was given as numbers.

    Examples
    --------
        Model()
        Monomer('A', ['b'])
        Monomer('B', ['b'])
        bind(A, 'b', B, 'b', [1e-4, 1e-1])
    """

    _verify_sites(s1, site1)
    _verify_sites(s2, site2)

    return _macro_rule('bind',
                       s1({site1: None}) + s2({site2: None}) <>
                       s1({site1: 1}) % s2({site2: 1}),
                       klist, ['kf', 'kr'])

#TODO: Refactor
def bind_table(bindtable, row_site, col_site):
    """This assumes that the monomers passed are in their desired state without
    the sites which will be used for binding.
    bindtable is a list of lists denoting the reactions between two types of
    reactants as follows:

    bindtable[0]: [                     reactypeA0,  ...,  reactypeAN]
    bindtable[1]: [reactypeB0,  (fwdrate, revrate),  ...,            ]
    bindtable[2]: [reactypeB1,                 ,     ...,            ]

    To indicate that no interaction occurs, simply enter None in the bind table.
    """

    # TODO return created components
    # TODO handle parameter objects and numbers
    # TODO full comments

    # parse the list, extract reactants, products and parameter families
    #first line is one set of reactants
    react_cols = bindtable[0]
    react_rows = [row[0] for row in bindtable[1:]]

    # Notice this makes intrxns indexed by intrxns[row][col]
    intrxns = [row[1:] for row in bindtable[1:]]

    # loop over interactions
    pc = 1 # parameter counter
    rc = 1 # rule counter, easy way of making sure names don't clash #FIXME
    for i in range(0, len(react_rows)):
        for j in range(0, len(react_cols)):
            if intrxns[i][j] is not None:
                kf, kr = intrxns[i][j]
                row_mpattern = react_rows[i]()
                col_mpattern = react_cols[j]()
                kf_parm = Parameter('bt%d%d_kf' % (i, j), kf)
                kr_parm = Parameter('bt%d%d_kr' % (i, j), kr)

                bind(react_rows[i](), row_site, react_cols[j](), col_site,
                     [kf_parm, kr_parm])

## Catalysis
def catalyze(enzyme, e_site, substrate, s_site, product, klist):
    """Generate the two-step catalytic reaction E + S <> E:S >> E + P.

    Parameters
    ----------
    enzyme, substrate, product : Monomer or MonomerPattern
        E, S and P in the above reaction.
    e_site, s_site : string
        The names of the sites on `enzyme` and `substrate` (respectively) where
        they bind each other to form the E:S complex.
    klist : list of 3 Parameters or list of 3 numbers
        Forward, reverse and catalytic rate constants (in that order). If
        Parameters are passed, they will be used directly in the generated
        Rules. If numbers are passed, Parameters will be created with
        automatically generated names based on the names and states of enzyme,
        substrate and product and these parameters will be included at the end
        of the returned component list.

    Returns
    -------
    components : ComponentSet
        The generated components. Contains two Rules (bidirectional complex
        formation and unidirectional product dissociation), and optionally three
        Parameters if klist was given as plain numbers.

    Notes
    -----
    When passing a MonomerPattern for `enzyme` or `substrate`, do not include
    `e_site` or `s_site` in the respective patterns. The macro will handle this.

    Examples
    --------
    Using distinct Monomers for substrate and product::

        Model()
        Monomer('E', ['b'])
        Monomer('S', ['b'])
        Monomer('P')
        catalyze(E, 'b', S, 'b', P, (1e-4, 1e-1, 1))

    Using a single Monomer for substrate and product with a state change::

        Monomer('Kinase', ['b'])
        Monomer('Substrate', ['b', 'y'], {'y': ('U', 'P')})
        catalyze(Kinase, 'b', Substrate(y='U'), 'b', Substrate(y='P'),
                 (1e-4, 1e-1, 1))

    """
    
    _verify_sites(enzyme, e_site)
    _verify_sites(substrate, s_site)

    # Set up some aliases to the patterns we'll use in the rules
    enzyme_free = enzyme({e_site: None})
    substrate_free = substrate({s_site: None})
    es_complex = enzyme({e_site: 1}) % substrate({s_site: 1})

    # if product is actually a variant of substrate, we need to explicitly say
    # that it is no longer bound to enzyme
    if product().monomer is substrate().monomer:
        product = product({e_site: None})
     
    # create the rules
    components = _macro_rule('complex',
                             enzyme_free + substrate_free <> es_complex,
                             klist[0:2], ['kf', 'kr'])
    components |= _macro_rule('dissociate',
                              es_complex >> enzyme_free + product,
                              [klist[2]], ['kc'])

    return components

def catalyze_state(enzyme, e_site, substrate, s_site, mod_site,
                   state1, state2, klist):
    """Generate the two-step catalytic reaction E + S <> E:S >> E + P.
    A wrapper around catalyze() with a signature specifying the state change
    of the substrate resulting from catalysis.

    Parameters
    ----------
    enzyme : Monomer or MonomerPattern
        E in the above reaction.
    substrate : Monomer or MonomerPattern
        S and P in the above reaction. The product species is assumed to be
        identical to the substrate species in all respects except the state
        of the modification site. The state of the modification site should
        not be specified in the MonomerPattern for the substrate.
    e_site, s_site : string
        The names of the sites on `enzyme` and `substrate` (respectively) where
        they bind each other to form the E:S complex.
    mod_site : string
        The name of the site on the substrate that is modified by catalysis.
    state1, state2 : strings
        The states of the modification site (mod_site) on the substrate before
        (state1) and after (state2) catalysis.
    klist : list of 3 Parameters or list of 3 numbers
        Forward, reverse and catalytic rate constants (in that order). If
        Parameters are passed, they will be used directly in the generated
        Rules. If numbers are passed, Parameters will be created with
        automatically generated names based on the names and states of enzyme,
        substrate and product and these parameters will be included at the end
        of the returned component list.

    Returns
    -------
    components : ComponentSet
        The generated components. Contains two Rules (bidirectional complex
        formation and unidirectional product dissociation), and optionally three
        Parameters if klist was given as plain numbers.

    Notes
    -----
    When passing a MonomerPattern for `enzyme` or `substrate`, do not include
    `e_site` or `s_site` in the respective patterns. In addition, do not
    include the state of the modification site on the substrate. The macro
    will handle this.

    Examples
    --------
    Using a single Monomer for substrate and product with a state change::

        Monomer('Kinase', ['b'])
        Monomer('Substrate', ['b', 'y'], {'y': ('U', 'P')})
        catalyze_state(Kinase, 'b', Substrate, 'b', 'y', 'U', 'P',
                 (1e-4, 1e-1, 1))
    """

    return catalyze(enzyme, e_site, substrate({mod_site: state1}),
                    s_site, substrate({mod_site: state2}), klist)

#TODO: Implement
def catalyze_table():
    pass

def catalyze_one_step(enzyme, substrate, product, kf):
    """Generate the one-step catalytic reaction E + S >> E + P.

    Parameters
    ----------
    enzyme, substrate, product : Monomer or MonomerPattern
        E, S and P in the above reaction.
    kf : a Parameter or a number
        Forward rate constant for the reaction. If a
        Parameter is passed, it will be used directly in the generated
        Rules. If a number is passed, a Parameter will be created with an
        automatically generated name based on the names and states of the
        enzyme, substrate and product and this parameter will be included
        at the end of the returned component list.

    Returns
    -------
    components : ComponentSet
        The generated components. Contains the unidirectional reaction Rule
        and optionally the forward rate Parameter if klist was given as a
        number.

    Notes
    -----
    In this macro, there is no direct binding between enzyme and substrate,
    so binding sites do not have to be specified. This represents an
    approximation for the case when the enzyme is operating in its linear
    range. However, if catalysis is nevertheless contingent on the enzyme or
    substrate being unbound on some site, then that information must be encoded
    in the MonomerPattern for the enzyme or substrate. See the examples, below.

    Examples
    --------
        Model()
        Monomer('E', ['b'])
        Monomer('S', ['b'])
        Monomer('P')
        catalyze_one_step(E, S, P, 1e-4)

    If the ability of the enzyme E to catalyze this reaction is dependent
    on the site 'b' of E being unbound, then this macro must be called as

        catalyze_one_step(E(b=None), S, P, 1e-4)
        
    and similarly if the substrate must be unbound.
    """

    return _macro_rule('one_step',
                       enzyme() + substrate() >> enzyme() + product(),
                       [kf], ['kf'])

def catalyze_one_step_reversible(enzyme, substrate, product, klist):
    """Create fwd and reverse rules for catalysis of the form:
       E + S -> E + P
           P -> S 

    Parameters
    ----------
    enzyme, substrate, product : Monomer or MonomerPattern
        E, S and P in the above reactions.
    klist : list of 2 Parameters or list of 2 numbers
        A list containing the rate constant for catalysis and the rate constant
        for the conversion of product back to substrate (in that order). If
        Parameters are passed, they will be used directly in the generated
        Rules. If numbers are passed, Parameters will be created with
        automatically generated names based on the names and states of S1 and
        S2 and these parameters will be included at the end of the returned
        component list.

    Returns
    -------
    components : ComponentSet
        The generated components. Contains two rules (the single-step catalysis
        rule and the product reversion rule) and optionally the two generated
        Parameter objects if klist was given as numbers.

    Notes
    -----
    Calls the macro catalyze_one_step to generate the catalysis rule.

    Examples
    --------
        Model()
        Monomer('E', ['b'])
        Monomer('S', ['b'])
        Monomer('P')
        catalyze_one_step_reversible(E, S, P, [1e-1, 1e-4])
    """

    components = catalyze_one_step(enzyme, substrate, product, klist[0])

    components |= _macro_rule('reverse', product() >> substrate(),
                              [klist[1]], ['k'])
    return components

## Synthesis and Degradation
# TODO: Implement
def synthesize_and_degrade():
    pass

# TODO: Implement
def synthesize_and_degrade_table():
    pass

## Pore assembly
# TODO: Refactor
def pore_species(subunit, site1, site2, size):
    """
    Generate a single species representing a homomeric pore, composed
    of <size> copies of <Subunit> bound together in a ring, with bonds
    formed between <site1> of one unit and <site2> of the next.
    """

    if size <= 0:
        raise ValueError("size must be an integer greater than 0")
    if size == 1:
        pore = subunit({site1: None, site2: None})
    elif size == 2:
        pore = subunit({site1: 1, site2: None}) % \
               subunit({site1: None, site2: 1})
    else:
        # build up a ComplexPattern, starting with a single subunit
        pore = subunit({site1: 1, site2: 2})
        for i in range(2, size + 1):
            pore %= subunit({site1: i, site2: i % size + 1})
        pore.match_once = True
    return pore

# TODO: Refactor
def assemble_pore_sequential(subunit, site1, site2, size, klist):
    """
    Generate rules to chain identical MonomerPatterns <Subunit> into
    increasingly larger pores of up to <size> units, using sites <site1>
    and <site2> to bind the units to each other.
    """
    if size != len(klist):
        raise ValueError("size and len(klist) must be equal")

    subunit = subunit()

    subunit_name = monomer_pattern_label(subunit)
    r_name_pattern = 'assemble_pore_sequential_%s_%%d' % (subunit_name)

    klist_clean = []
    params_created = ComponentSet()
    for i, sublist in enumerate(klist):
        r_name = r_name_pattern % (i + 2)
        if all(isinstance(x, Parameter) for x in sublist):
            kf, kr = sublist
        elif all(isinstance(x, numbers.Real) for x in sublist):
            # if sublist is numbers, generate the Parameters
            kf = Parameter(r_name + '_kf', sublist[0])
            kr = Parameter(r_name + '_kr', sublist[1])
            params_created.add(kf)
            params_created.add(kr)
        else:
            raise ValueError("klist must contain Parameters objects or numbers")
        klist_clean.append([kf, kr])

    rules = ComponentSet()
    for i in range(2, size + 1):
        M = pore_species(subunit, site1, site2, 1)
        S1 = pore_species(subunit, site1, site2, i-1)
        S2 = pore_species(subunit, site1, site2, i)
        r = Rule(r_name_pattern % i, M + S1 <> S2, *klist_clean[i-2])
        rules.add(r)

    return rules | params_created

# TODO: Refactor
def pore_transport(subunit, sp_site1, sp_site2, sc_site, min_size, max_size,
                   csource, cdest, c_site, klist):
    """
    Generate rules to transport MonomerPattern <csource> to <cdest> (cargo)
    through any of a series of pores of at least <min_size> and at most
    <max_size> subunits binding on <spsite1> and <spsite2>. Subunit and cargo
    bind at sites scsite and csite, respectively.
    """

    # turn any Monomers into MonomerPatterns
    subunit = subunit()
    csource = csource()
    cdest = cdest()

    # verify that sites are valid
    if sc_site not in csource.monomer.sites_dict:
        raise ValueError("sc_site '%s' not present in csource '%s'" %
                         (sc_site, csource.monomer.name))
    if sc_site not in cdest.monomer.sites_dict:
        raise ValueError("sc_site '%s' not present in cdest '%s'" %
                         (sc_site, cdest.monomer.name))

    subunit_name = monomer_pattern_label(subunit)
    csource_name = monomer_pattern_label(csource)
    cdest_name = monomer_pattern_label(cdest)

    rc_name_pattern = 'transport_complex_%s_pore_%%d_%s' % \
                      (subunit_name, csource_name)
    rd_name_pattern = 'transport_dissociate_%s_pore_%%d_from_%s' % \
                      (subunit_name, cdest_name)

    for i in range(min_size, max_size + 1):
        pore = pore_species(subunit, sp_site1, sp_site2, i)
        # require all pore subunit sites to be empty for match
        for mp in pore.monomer_patterns:
            mp.site_conditions[sc_site] = None

        rc_name = rc_name_pattern % i
        rd_name = rd_name_pattern % i

        rule_rates = rates[i-min_size]
        cpore = pore._copy()
        source_bonds = range(i+1, i+1+i)
        for b in range(i):
            cpore.monomer_patterns[b].site_conditions[sc_site] = \
                                                            source_bonds[b]
        sc_complex = cpore % csource({c_site: source_bonds})
        Rule(rc_name, pore + csource({c_site: None}) <> sc_complex,
             *rule_rates[0:2])
        Rule(rd_name, sc_complex >> pore + cdest({c_site: None}), rule_rates[2])
   
